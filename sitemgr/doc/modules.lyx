#LyX 1.2 created this file. For more info see http://www.lyx.org/
\lyxformat 220
\textclass docbook
\begin_preamble
<!entity header system "header.sgml">
\end_preamble
\language english
\inputencoding default
\fontscheme default
\graphics dvips
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip smallskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title
\added_space_top vfill \added_space_bottom vfill 
Introduction to sitemgr modules
\layout Date

January 1, 2003
\layout Author


\begin_inset ERT
status Open

\layout Standard
<firstname>Michael</firstname> <surname>Totschnig</surname>
\end_inset 


\layout Abstract

This text provides an overview of sitemgr's proposed new modularized architectur
e and contains the information users, administrators, template designers
 and application devellopers need in order to get started using sitemgr
 as a flexible web site managment system that can easily make any information
 and business logic phpgroupware knows about publicly accessible.
 This text also serves as a request for comments, so that sitemgr's new
 generation can be adapted quickly to the needs of PHPgroupware's user community.
 Please be aware that at the moment the new sitemgr is still experimental
 and that there are some areas of its functionnality that need further developpm
ent.
\layout Section

Introduction
\layout Standard

For the next generaton of phpgroupware's web site managment application
 sitemgr, we propose a new page generation architecture whose fundamental
 idea is that all dynamic web site content is built by modules.
 In this section, I will sketch a short outline of how this architecture
 works and I will present the concepts it makes use of.
\layout Subsection

Template
\layout Standard

Sitemgr builds web sites from templates.
 Those are stored in the directory sitemgr/sitemg-site/templates.
 Each of them has a directory of its own.
 The file main.tpl defines the template of the whole site, there can be other
 files that define code for separate areas of the page or for specific modules.
 Templates contain four kinds of variables.
 These are explained here since the types 2,3 and 4 can be used both in
 the template as in the page content a module generates.
\layout Enumerate

{
\series bold 
contentarea
\series default 
: areaname} These define where administrator and contributor provided content
 go.
 The names and the number of contentareas a template defines are almost
 arbitrary.
\layout Enumerate

{appname.modulename(?arguments)}These let you hardcode a call to a module
 into a template.
 Arguments are in the HTTP GET query string syntax (?key1=value1&key2=value2).
 At the moment, if you use this type of variables, you have to urlencode
 the query string yourself.
 Future versions of sitemgr might provide a simpler notation.
 For example,{sitemgr.lang_block] creates the select box for multilingual
 sites.
\layout Enumerate

{?(
\series bold 
phpgw|sitemgr
\series default 
:)link} This lets you create links either to other pages of your website,
 or to phpgroupware applications:
\begin_deeper 
\layout Enumerate

Links to sitemgr either start with '?sitemgr:' or only with '?'.
 You can either link to a page with {?page_name=downloads] and [?page_id=4},
 to a category's index (?category_id=5), to the site index (?index), to
 the site's table of contents (?toc).
 Just [?] or {?sitemgr:} links to the administrator defined home page.
\layout Enumerate

Links to phpgw start with '?phpgw:' .
 You have to name the application followed by a comma, and optionnally arguments
 the application can interpret.
 For example {?phpgw:/addressbook,order=n_given&sort=ASC}.
\end_deeper 
\layout Enumerate

{variable} Finally there are some simple variables you can use to retrieve
 metainformation about the page or about the user's context:
\begin_deeper 
\layout Enumerate

{title} the page title
\layout Enumerate

{subtitle} the page subtitle
\layout Enumerate

{sitename}the sitename the administrator has chosen for the site
\layout Enumerate

{footer}the administrator edited footer
\layout Enumerate

{header}the administrator edited header
\layout Enumerate

{user}the user's account name
\end_deeper 
\layout Subsection

Module
\layout Standard

The main function of a sitemgr module is to generate dynamic web site content.
 To make the development of new modules, and the use of modules easy and
 convenient, sitemgr defines an 
\begin_inset Quotes eld
\end_inset 

abstract
\begin_inset Quotes erd
\end_inset 

 class module which each module should extend.
 This parent of all modules, provides one essential service: It hooks the
 module into the content managment interface and permits the editing of
 the module's arguments that determine what content will be generated.
 Thus in order to create a new module, all you have to do, is to extend
 the abstract super module, define the modules arguments, and write a get_conten
t function that returns the content that should be displayed on the website.
 More on this in chapter
\begin_inset ERT
status Open

\layout Standard
<link linkend="Application-developper-manual">5</link>
\end_inset 

.
\layout Subsection

Argument/Content
\layout Standard

A module can be seen as a transformation of input arguments into generated
 content.
 It is important to understand that the input arguments can be of completely
 different kinds.
 On the one hand there can be arguments that are as close as possible to
 the generated content.
 For example the html module's only argument is named 
\begin_inset Quotes eld
\end_inset 

htmlcontent
\begin_inset Quotes erd
\end_inset 

 and in normal circumstances it is not transformed at all but handed over
 as is to the page generation engine.
 On the other hand arguments can play any conceivable role in the generation
 of content that is driven by data coming from other phpgroupware applications.
 They can be used to select between different categories of content, they
 can choose a certain format of presentation, they can function as search
 terms, etc.
\layout Subsection

Properties
\layout Standard

A module can define properties.
 Properties are accessible to the modules get_content function in the same
 way as arguments, but they differ from them in two ways:
\layout Itemize

Properties are edited by the site administrator.
 Their intended role is to put certain constrains on the workings of the
 module, so that a site administrator can enforce certain rules.
 For example the standard html module defines a property called striphtml.
 If this boolean property is set the module replaces all html in the generated
 content with entities.
\layout Itemize

Properties are not defined with respect to a certain generated content block,
 but are defined either on a site-wide level or on the level of specific
 categories.
 Additionally you can differenciate on each scope properties for each content
 area.
 When a content block is generated, properties are searched for in a cascading
 way, i.e.
 when the block is specific to a specific page and contentarea and the module's
 properties are not defined for the combination of the contentarea and the
 page's category, then properties defined for higher scopes are looked for
 in a certain order.
 More on this in chapter
\begin_inset ERT
status Open

\layout Standard
<link linkend="Administrator-manual">3</link>
\end_inset 

.
\layout Subsection

Blocks, content areas and scope
\layout Standard

There are three ways a module can generate content that will be displayed
 on a web page:
\layout Enumerate

A template can contain hardcoded calls to modules that will generate content
 visible on each page.
 Thus you could put dynamic content that is visible across the whole site
 on a place of its own directly into the template.
 But beware that restrictions defined by the administrator also apply to
 these hardcoded module calls.
\layout Enumerate

A template defines several content areas.
 This is one important differenced between the modularized sitemgr and previous
 versions where there were was only one place where contributor edited content
 went (page_content) and two places for administrator configured blocks
 (right_blocks, left_blocks).
 Now templates can define any practical number of content areas with arbitrary
 names.
 And there is no more much difference between central and peripheric areas.
 All can show administrator and contributor provided block content.With one
 exeption: The name 
\begin_inset Quotes eld
\end_inset 

center
\begin_inset Quotes erd
\end_inset 

 is special in that special pages that get generated by special URLs like
 
\begin_inset Quotes eld
\end_inset 

?toc
\begin_inset Quotes erd
\end_inset 

 and 
\begin_inset Quotes eld
\end_inset 

?index
\begin_inset Quotes erd
\end_inset 

 or 
\begin_inset Quotes eld
\end_inset 

?category_id=number
\begin_inset Quotes erd
\end_inset 

 always put there page content (which is internally generated by nothing
 else than a module) into this content area.
 If your template does not have a content area called 
\begin_inset Quotes eld
\end_inset 

center
\begin_inset Quotes erd
\end_inset 

 these special URLs won't work.
\newline 
Content areas can display module output, as edited by the page's contributors.
 We refer to each output of a module as a block.
 Here is another important difference to how sitemgr used to work: Until
 now there was a sharp distinction between page content which replaces the
 template variable page_content, and side blocks which got defined in a
 special file called blockconfig and replaced the template varialbes right_block
s and left_blocks.
 Now from the perspective of the page generation engine there is no more
 any difference between content areas, all display blocks of content generated
 by modules.
\newline 
The blocks one content area displays can be defined on different levels
 of scope: There are site wide blocks that are visible across the whole
 site, category wide blocks, that are visible on pages that belong to the
 category or any of its children, and finally are page blocks that define
 what distinguishes the page from other pages, and normally will be that
 what you'd call the page's main content.
\layout Enumerate

The block content generated by a module can contain template variables of
 the same type as those that can be hardcoded.
 This is mostly useful for modules like the html module, where the contributor
 specified argument is nearly identical to the generated content.
 Thus a contributor can embed module calls inside the content of a certain
 block.
 This is done only once without any recursion, i.e.
 if a embedded module call returns itself a template variable it is not
 parsed and processed again.
\layout Subsection

Transformer
\layout Standard

The architecture for sitemgr modules provides for the distinction between
 some form of raw content a module produces and the way it should get displayed
 on the web site, with the future possibility to plug other display types
 into the same framework.
 The idea is that the raw content of a module gets passed through different
 transformers, possibly even several transformers in a sequence at the time
 of content generation.
 Additionally this provides for a use of modules outside of sitemgr, for
 example remote retrieval of information with something like XML-RPC.
 
\layout Standard

At the moment, a module does not need to use transformers on its own, it
 can directly generate html content, but if it does, sitemgr provides for
 an easy way to chain different transformers together.
 Thus a module can be constructed in different layers of functionality.
 For example a module's get_content function could return data inXML, and
 it defines a XSLT transformation to reorganize this data, and a second
 transformer for creating a user interface for display.
\layout Standard

Transformers are also used on the level of the site template, insofar as
 each contentarea can have an associated transformer, which wraps the different
 content blocks into a common display format.
 This does the same thing as the file sideblock.tpl in former versions of
 sitemgr.
\layout Subsection

Translations
\layout Standard

Sitemgr in its new modularized architecture continues to be fully multilingual.
 It is very simple to have a new module use this feature.
 All that is needed is to use a special flag in the definition of the module's
 arguments.
 All arguments that have this flag will be stored in a language specific
 database table, and can be translated in the translation manager, very
 similar to the way category and page definitions could already be translated
 to several languages.
\layout Section

User manual
\layout Standard

The most important difference for site contributors between the modularized
 sitemgr and its older versions is that in the page manager now there are
 two different interfaces for each page:
\layout Enumerate

When you create a new page or when you click on the Edit button which is
 associated with an existing page, you no longer edit the page content,
 but only some basic metainformation about the page as its name, title,
 subtitle and sort order, and you can change the category the page belongs
 to.
\layout Enumerate

There is a new interface that gets displayed when you click on a page's
 
\begin_inset Quotes eld
\end_inset 

Manage content
\begin_inset Quotes erd
\end_inset 

 button.
 It is here that you create the content blocks for each page.
\layout Standard

The second difference is that now a contributor can also define content
 blocks for the whole category he has write access for.
 These category wide blocks will be seen on each page that belongs to the
 category or to any of its subcategories.
 There are also side wide content blocks that only the site administrator
 can create.
\layout Standard

The interface for creating content blocks is the same on each level of scope,
 besides that when editing blocks on a lower level you can see all the blocks
 that have been defined on a higher level, and will be displayed on the
 website together with the blocks you are editing.
 I will refer to this interface as the content manager.
\layout Standard

In each content manager, there is a section for each content area, where
 you can add blocks selected from a menu of all available modules.
 Once you have added a new block, it appears amidst all other blocks of
 the content area.
 Those defined on higher level scopes are only displayed, those pertaining
 to the scope (site-wide, category or page) you are managing are editable.
 There are four standard interface elements you can edit for each block:
\layout Description

Title Each module defines a default title for blocks it generates.
 The block title is not necessarily displayed in each content area.
 It depends on the block transformer defined for the content area by the
 site template you use.
 Here you can override the default title with a customized title that will
 only be used by the block you are editing.
\layout Description

Actif When you create a new block, it is not immediately visible on the
 web site.
 This makes sense since you need to edit its arguments first.
 When you are finished defining a blocks arguments, you have to check the
 actif flag to make it visible.
 This can also be practical if you want to hide some content temporarily
 from the web site without deleting it from the database.
\layout Description

Seenby You can control the visibility of each block for the different user
 roles defined by sitemgr: site administrators, phpgroupware users (which
 include site administrators) and the anonymous user.
 Evidently you can also make the block visible for everyone which is the
 default.
 
\layout Description

Sortorder Here you can change the order in which the blocks are displayed
 by defining a different integer for each block.
\layout Standard

After these, you have to edit the module specific arguments, each of which
 is preceded by an explanatory label.
 The input elements for arguments can be of different types: checkboxes,
 selectboxes, textareas, textfields.
 In the case of text input, you can use the same template variables as are
 used in the site template.
 But be aware that this only works if the module puts the same variable
 into its output, which need not necessarily be the case.
\layout Section

Administrator manual
\begin_inset LatexCommand \label{Administrator-manual}

\end_inset 


\layout Subsection

Installation
\layout Enumerate

Once you have the sitemgr directory inside your phpgroupware install you
 can setup it like any other phpgroupware application with the setup program
 (http://yourmachine/phpgw-path/setup/).
 You should also install the sitemgr-link application, which is is inside
 sitemgr and has to be moved up in the directory hierarchy.
\begin_deeper 
\layout Code

cd sitemgr
\layout Code

mv sitemgr-link ..
\layout Standard

and then install sitemgr-link with setup
\end_deeper 
\layout Enumerate

Log in to phpGroupWare as an admin and create an anonymous phpgw user and
 assign it a password.
 The only app (I assume) that they should have access to is sitemgr-link.
 sitemgr-link is a dummy application that redirects phpGW users to the generated
 site.
\layout Enumerate

Users who you wish to see sitemgr (aka contributors) must be given acces
 to sitemgr, users who you want to be able to link to the sitemgr site from
 phpGW must be given rights to sitemgr-link.
 The easiest way to do this is to go to User groups and give groups permissions
 to use the applications.
 
\layout Enumerate

The sitemgr-site is the directory that serves the dynamic web site.
 It is located inside sitemgr and works without moving it somewhere else.
 But it can be located anywhere.
 For example, you could put it in /var/www/html.
 You could make the root location of your web server point to it, if you
 wish (ie, http://yourmachine/ refers to /var/www/html/sitemgr-site if you
 moved the directory, or to /path/to/phpgroupware/sitemgr/sitemgr-site if
 you did not).
 Make a mental note of the directory where you put it and the url that it
 is accessed by.
\layout Enumerate

In the sitemgr-site directory is a file called config.inc.php.
 You only have to edit it if you moved the directory.
 Change the value of the line
\begin_deeper 
\layout Code

'phpgw_path'           => '../../',
\layout Standard

so that the value of $sitemgr_info['phpgw_path'] is '/path/to/phpgroupware/'
\end_deeper 
\layout Enumerate

You're almost set to go.
 Log in to phpGroupWare as an adminis trator.
 Make sure you gave yourself the sitemgr and sitemgr-link applications so
 that you see them on your navbar.
 Go to the sitemgr application and select "Configure SiteMgr".
 Fill in 
\begin_inset Quotes eld
\end_inset 

URL to sitemgr-site
\begin_inset Quotes erd
\end_inset 

 and 
\begin_inset Quotes eld
\end_inset 

Filesystem path to sitemgr-site directory
\begin_inset Quotes erd
\end_inset 

, and the anonymous user's name and password.
 Then click on save, and you should know select the template for your site.
\layout Enumerate

That's it.
 Go to the Category manager, add a category or three and check who can view
 and edit them, then go to the page manager, add a page or three to each
 category, set up your site header, site footer, etc., and go view your recently
 created site by clicking on the sitemgr-link application.
 Voilà!
\layout Subsection

Maintenance
\layout Standard

As a site administrator, you have three privileges/responsibilies:
\layout Enumerate

Define site wide content blocks.
 These are edited in the same interface as category and page specific blocks.
\layout Enumerate

Choose permitted modules: If you choose 
\begin_inset Quotes eld
\end_inset 

Manage site-wide module properties
\begin_inset Quotes erd
\end_inset 

 from sitemgr's main menu, you will see several rows which all contain four
 elements: a select box, a button labelled 
\begin_inset Quotes eld
\end_inset 

Select allowed modules', another select box and a button labelled 
\begin_inset Quotes eld
\end_inset 

Configure module properties
\begin_inset Quotes erd
\end_inset 

.
 The first select box and its adjacent button in each row permits to choose
 lists of permitted modules.
 The first row defines a master list for the whole site which is used when
 no more specific lists are found for content areas or categories.
 The following rows each pertain to the different content areas of your
 site template.
 Here you can choose to allow some modules for one content areas, and other
 modules for another one.
\newline 
In the category manager, there is a button 
\begin_inset Quotes eld
\end_inset 

Manage Modules
\begin_inset Quotes erd
\end_inset 

 associated with each category.
 There you can use the same interface to define lists specific to one category
 (and all its subcategories, unless overriden).
 Again you have the choice between one list that pertains to all content
 areas, and specific lists for each category.
\newline 
When sitemgr has to find a specific value of permitted lists in a given
 context (a given contentarea in a given category) the following algorithm
 is used: First it aks for a value defined for the pair contentarea/category.
 If none is defined, it climbs up the category hierarchy until the site
 wide value, each time looking for a value defined for the pair contentarea/cate
gory.
 If none can be found, it returns to the given category the search started
 from, and now asks for values defined for the given category but independent
 from the contentarea.
 If there is still none defined, it repeats the same traversal up the category
 hierarchy.
 This means that by simply defining one global master list of permitted
 modules, you can configure the whole site, if you do not need more fine
 grained control.
\newline 
The lists of permitted lists are never merged, if you define one list for
 a given context, this list is used in this context.
\layout Enumerate

Define module properties: The lookup algorithm for module properties is
 exactly the same as for the lists of permitted modules.
 For each module you can set properties for the whole site, for content
 areas, for categories, or for combinations of content areas and categories.
 You access the property editor from the same page where you choose the
 list of permitted modules.
 You just use the second select box in each row.
 By selecting one module and clicking the 
\begin_inset Quotes eld
\end_inset 

Configure module properties
\begin_inset Quotes erd
\end_inset 

 button, you will open a interface for editing the module's properties which
 ressembles the interface for editing module arguments in the content manager.
 Be aware that only some modules define properties.
\layout Section

Template designer manual
\begin_inset LatexCommand \label{Template-designer-manual}

\end_inset 


\layout Standard

One main idea behind sitemgr's modularized architecture is that all dynamic
 content on the website is produced by a module.
 This permits for a very structural way of defining functionality and for
 an easy way of extending functionality.
 With respect to former versions of sitemgr, this means that the templates
 have to be slightly modified:
\layout Itemize

The whole page template is now stored in a file main.tpl in the template's
 directory.
\layout Itemize

The variables page_content, left_blocks,right_blocks have to be replaced
 by content areas: {contentarea:center}, {contentarea:left}, {contentarea:right}.
 Only the contentarea center has a special semantics, since it is the hardcoded
 value for the display of table of contents and side index.
 All other contentareas can have arbitrary names, and you can have any practical
 number of them.
\layout Itemize

A contentarea serves to display the content blocks, the site administrator
 and contributors define.
 Each contentarea can have its own way of wrapping html code around each
 content block.
 This at the moment defined in a class that implements the transformer interface
, i.e.
 defines a function apply_transform($title,$content).This class' name is
 areaname_bt (for blocktransformer) and it is stored in file areaname_bt.inc.php
 inside the template directory.
 The function apply_transform just has to wrap the desired html around the
 content.
 It is free to ignore the title, for example the block title does not necessaril
y make sense in a page's central content area.
 A block transformer could apply other transformations to the content, but
 this would probably have counter-intuitive effects on your page's contributors.
\layout Itemize

Other than that a template directory can contain template files that are
 specific to a certain module.
 For example the news module uses a file newsblock.tpl which is a standard
 API template.
 It is up to a module's developpers what kind of templates he wants to use.
 We propose to use a namespace for these module specific template files.
 For example a template used by module 'news_admin.news' would go into a
 subdirectory 'news_admin/news' in each template directory.
 If the module does not find a template it needs in the site template's
 directory, it should look for a default template file, for example in 
\begin_inset Quotes eld
\end_inset 

default/news_admin/news'.
\layout Itemize

You can hardcode module calls into the template if your site should have
 the same dynamic content on one specific place.
\layout Section

Application developper manual
\begin_inset LatexCommand \label{Application-developper-manual}

\end_inset 


\layout Standard

Sitemgr's parent module class, defines all the important functionality a
 module needs in its lifetime.
 Thus creating a new module can be as easy as creating a class that extends
 the standard module, defines the module's arguments if there are any, and
 has a function get_content that produces the module's content.
 Let's start with 
\begin_inset Quotes eld
\end_inset 

Hello World
\begin_inset Quotes erd
\end_inset 

.
\layout Code

<?php
\layout Code

\layout Code

class module_hello extends Module 
\layout Code

{      
\layout Code

    function module_hello()  
\layout Code

    {               
\layout Code

        $this->arguments = array(
\layout Code

            'name' => array(
\layout Code

                'type' => 'textfield', 
\layout Code

                'label' => 'The person to say hello to'
\layout Code

            )
\layout Code

        );
\layout Code

        $this->title = "Hello world";
\layout Code

        $this->description = "This is a simple sample module";   
\layout Code

    }
\layout Code

\layout Code

    function get_content($arguments,$properties)    
\layout Code

    {
\layout Code

        return lang('Hello') .
 ' ' .
 $arguments['name'];
\layout Code

    }
\layout Code

}
\layout Standard

Once your module is registered and added to the list of permitted modules
 for some context, users can create blocks from this module: They will see
 in the content manager a textfield where they edit the argument name, and
 once the block is activated, it will generate the hello phrase on the website.
 Easy, isn't it?
\layout Standard

Now let's examine more in detail how the standard module is constructed.
 This will help you understand in what way you can extend it to create more
 powerful modules.
 It defines the following functions:
\layout Description

add_transformer($transformer) This function adds a transformer class to
 the module's transformer chain, so that when a block is generated from
 this module, its content will be passed through $transformer.
 This function is automatically called for block transformers, but you can
 use it on your own, if you want to separate in your module raw content
 from different forms of output.
 There is only one function a transformer class has to provide:
\begin_deeper 
\layout Description

apply_transform($title,$content) A transformer that is not a block transformer
 should normally ignore the title argument, and construct its return value
 from the content argument.
\end_deeper 
\layout Description

set_block($block,$produce=False) This function is called by the content
 manager (with $produce=False) and by the page generation (with $produce=True)
 for each content block, so that the module knows everything about the block
 it has to edit or generate (above all its context and its arguments).
 If your module overrides this function, it should always call the parent
 class' set_block function first with parent::set_block($block).
 If you want to configure your module with respect to the block, you can
 do this here.
 This is also the place where your module should add the transformers it
 needs for generating output.
 For example:
\layout Code

function set_block($block) 
\layout Code

{ 
\layout Code

    parent::set_block($block);
\layout Code

    if ($produce)
\layout Code

    {
\layout Code

        $this->add_transformer(new my_transform());
\layout Code

    }
\layout Code

}
\layout Description

get_properties() This function looks up the value of the module's properties
 for the context of a block.
 There should not be much reason to override this function.
\layout Description

get_user_interface() This function is responsible for creating the interface
 you use in the content manager when you edit a module's arguments.
 If you want this interface to show more than your module's arguments, youcan
 override this function.
 It must return an array of interface elements where each element is an
 array with two values associated to the keys label and form.
 You can even dynamically construct arguments, sitemgr's sample gallery
 module shows how to do this.
\layout Description

get_admin_interface($defaults) This function creates the interface for editing
 module properties, it works in a similar way to get_user_interface.
\layout Description

get_translation_interface($fromblock,$toblock) This function creates the
 interface for the translation manager.
 If your module makes use of sitemgr multilingual feature, and you have
 overriden get_user_interface, you'll probably have to override this function
 too.
\layout Description

build_input_element(($input,$default,$elementname) This is a helper function
 for above functions.
 If you override one of above functions you can use build_input_element
 in the same way as the parent module does.
\layout Description

validate(&$data) This function is called when a module's arguments are edited.
 The parent class simply returns true.
 When you override this function, you can alter the arguments, a reference
 to which is passed to the function, but you can also return false, and
 set the module's validation_error variable.
 In this case, the arguments will not be saved and the validation error
 is displayed to the user.
 For example we could add the following lines to our hello module:
\begin_deeper 
\layout Code

function validate(&$data) 
\layout Code

{ 
\layout Code

    if (preg_match("/[[:upper:]]/",$data['name']))
\layout Code

    {
\layout Code

        $data['name'] = strtolower($data['name']);
\layout Code

        $this->validation_error = "Name has been translated to lower case";
\layout Code

    }
\layout Code

    return true;
\layout Code

}
\layout Standard

This would make sure that the module argument name would always be lowercase.
\end_deeper 
\layout Description

get_content(&$arguments,$properties) This is the function every module needs.
 It produces the module's content.
 It is passed two arrays, one with the arguments for the block the module
 is generating, and the other with the properties that apply for the block's
 context.
 At the moment there is no constraint on what type of date the get_content
 function returns.
 It can be html, xml, an array, etc.
 But if it does not return html, you have to provide a transformer capable
 to produce html from the data get_content produces.
 The arguments are passed as a reference, because the get_content function
 can change them, and they can get stored automatically as session variable.
 This is because the parent module provides one other service: Your module
 can rely on an automatic handling of HTTP GET, POST and COOKIE variables,
 and of session variables.
 All you'd have to do is to define the arrays $this->get, $this->post, $this->co
okie and $this->session.
 All members of these variables will be fetched from the GET, POST or COOKIE
 parameters, or from session variables and stored for you in the $arguments
 array.
 The entries of $this->session additionnaly will be stored after get_content
 returns to get_output.
 This can be very useful if you want your module do remain in a stable state
 while the user interacts with other modules on the same page.
\begin_deeper 
\layout Standard

The variables you define in these arrays can be identical to those in $this->arg
uments.
 In this case, if they are defined in the HTTP session context, they will
 override the values the page contributor has defined for the page.
 But they can be different variables that do not need an initial value provided
 by the page contributor.
 Whereas $this->get,$this->cookie and $this->session are simple arrays enumerati
ng the variable names, $this->post is special because it can contain the
 element definition in the same way as $this->arguments, which can be used
 to programatically construct the form elements.
\layout Standard

Your module does not need to use this service, it could directly read HTTP
 variables.
 The advantage of using it is that it provides a namespace for each module,
 so that if you use different modules on the same page, that use the same
 variable names, you would not run into problems.
 If you use this service you can construct URLS automatically with the modules
 link function (see below), and if you construct the user interface, you
 have to provide the correct form element names for this service to work.
 The build_post_element function can help you do this.
 For example lets extend our hello module, so that the site user can choose
 his own name.
 Since we can no longer rely on the validation that is automatically done
 on contributor provided input.
 we call validate from the get_content function.
\layout Code

<?php
\layout Code

\layout Code

class module_hello extends Module  {
\layout Code

    function module_hello()
\layout Code

    {
\layout Code

        $this->name = "hello";
\layout Code

        $this->arguments = array(
\layout Code

            'name' => array(
\layout Code

                'type' => 'textfield',
\layout Code

                 'label' => 'The person to say hello to'
\layout Code

            )
\layout Code

        );
\layout Code

       $this->post = array('name' => array('type' => 'textfield'));
\layout Code

       $this->session = array('name');
\layout Code

       $this->title = "Hello world";
\layout Code

       $this->description = "This is a simple sample module";
\layout Code

    }
\layout Code

    function get_content(&$arguments,$properties)
\layout Code

    {
\layout Code

       $this->validate($arguments);
\layout Code

       return lang('Hello') .
 ' ' .
 $arguments['name'] .
 '<br><form action="' .
\layout Code

           $_SERVER['REQUEST_URI'] .
 '" method="post">' .
\layout Code

               $this->build_post_element('name',lang('Enter a name') .
\layout Code

           '</form>';
\layout Code

    }
\layout Code

\layout Code

    function validate(&$data)
\layout Code

    {
\layout Code

       if (preg_match("/[[:upper:]]/",$data['name']))
\layout Code

       {
\layout Code

           $data['name'] = strtolower($data['name']);
\layout Code

           $this->validation_error = "Name has been translated to lower
 case";                }
\layout Code

       return true;
\layout Code

   }
\layout Code

}
\end_deeper 
\layout Description

build_post_element($key,$default=False) You can use this function from your
 module's get_content function to construct form elements.
 This works with the argument definition you put into $this->post.
 If you do not provide a default the current blocks value for the argument
 will be filled in.
\layout Description

link($modulevars) helps you construct URLS with GET parameters that use
 the service described above.
 modulevars is an array of variable values keyed on variable names.
\layout Description

get_output($type='html') This is the function that is actually called by
 the page generation engine, since it not only calls the module's get_content
 function, but makes sure that all transformers that have been added to
 the modules transformer_chain get called.
 For type argument is not really used at the moment, but future versions
 of sitemgr could be extended so that modules could produce output in different
 formats by specifying different transformers for each output type.
 Your module should not need to override get_output.
\layout Standard

To summarize, there are the following requirements for a sitemgr module:
\layout Enumerate

It is written as a class called module_name and extends the class Module.
 It must be put into a file called class.module_name.inc.php and put into the
 inc directory of any phpgroupware application.
\layout Enumerate

Its constructor should define the following member variables:
\begin_deeper 
\layout Enumerate

arguments: the module's arguments a contributor can edit in order to create
 content blocks from the module.
 Each argument needs to define a label and the type of input element used
 to edit it in the content manager.
 Parameters for these input elements (like size for textfields, cols and
 rows for textareas can be defined).
 Translatable arguments can be specially flagged with a i18n entry in the
 arguments definition array.
\layout Enumerate

properties: the module's properties the site administrator can edit in order
 to constrain or configure the functionnality of the module
\layout Enumerate

title: The module's default title that can be overriden for each content
 block.
\layout Enumerate

description: A short descriptive text, that is displayed in the content
 manager and module manager (for example when you put the mouse over an
 entry in the module select lists).
\end_deeper 
\layout Enumerate

It needs a get_content function that has access to arguments and properties
 ans produces the block content.
\layout Enumerate

If the content returned by get_content is something different from HTML,
 the module has to define transformer classes, and should add them to the
 module's transformer chain.
 This can be done in the constructor, but the best place for it is the set_block
 function
\layout Enumerate

The parent module class provides a user interface for editing module arguments.
 If a module needs a customized interface or wants to construct arguments
 dynamically, it can override the get_user_interface function.
\layout Standard

These are the building blocks which should allow for some flexibility in
 constructing modules that make phpgroupware managed data visible on a sitemgr
 web site.
\the_end
